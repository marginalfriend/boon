---
title: "Building with Svelte 5: A Practical Guide to Runes"
date: "2026-01-15"
description: "An in-depth look at Svelte 5's runes system and how it changes the way we think about reactivity"
draft: false
---

## Building with Svelte 5

Svelte 5 represents the most significant evolution of the framework since its inception. The introduction of **runes**—a new primitive for declaring reactive state—fundamentally changes how we write Svelte applications.

### Understanding Runes

In Svelte 4, reactivity was implicit. Any top-level `let` declaration in a component was automatically reactive:

```js
// Svelte 4 - implicit reactivity
let count = 0;
$: doubled = count * 2;
```

Svelte 5 makes this explicit with runes:

```js
// Svelte 5 - explicit reactivity with runes
let count = $state(0);
let doubled = $derived(count * 2);
```

### The Core Runes

#### `$state` — Reactive State

The `$state` rune creates reactive state that triggers updates when modified:

```js
let user = $state({
  name: 'Abun',
  email: 'abun@example.com'
});

// Mutations are tracked deeply
user.name = 'Updated Name'; // This triggers reactivity
```

#### `$derived` — Computed Values

For values that depend on other reactive state:

```js
let items = $state([1, 2, 3, 4, 5]);
let total = $derived(items.reduce((sum, n) => sum + n, 0));
let average = $derived(total / items.length);
```

#### `$effect` — Side Effects

When you need to react to state changes:

```js
$effect(() => {
  console.log(`Count changed to: ${count}`);
  // Cleanup function (optional)
  return () => console.log('Cleaning up...');
});
```

### Why I Prefer Explicit Reactivity

After building several projects with Svelte 5, I've come to appreciate the explicitness:

1. **Clarity** — You know exactly what's reactive at a glance
2. **Refactoring** — Extract logic to functions without losing reactivity
3. **TypeScript** — Better type inference and IDE support
4. **Debugging** — Easier to trace reactive dependencies

### A Practical Example

Here's a todo list component showcasing the runes:

```svelte
<script>
  let todos = $state([]);
  let newTodo = $state('');
  
  let completedCount = $derived(
    todos.filter(t => t.done).length
  );
  
  function addTodo() {
    if (newTodo.trim()) {
      todos.push({ text: newTodo, done: false });
      newTodo = '';
    }
  }
</script>

<input bind:value={newTodo} />
<button onclick={addTodo}>Add</button>
<p>{completedCount} of {todos.length} completed</p>
```

### Migration Tips

If you're migrating from Svelte 4:

- Start with `$state` for your component state
- Replace `$:` reactive statements with `$derived`
- Use `$effect` sparingly—often derived state is sufficient
- The migration can be gradual; both syntaxes work during transition

### Conclusion

Svelte 5's runes represent a maturation of the framework. While the implicit reactivity of earlier versions was magical, the explicit approach scales better and integrates more naturally with modern JavaScript patterns.

The learning curve is gentle if you're already familiar with Svelte, and the benefits become apparent as your applications grow in complexity.
