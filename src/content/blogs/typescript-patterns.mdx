---
title: "TypeScript Patterns I Use Every Day"
date: "2026-01-10"
description: "Practical TypeScript patterns that have improved my code quality and developer experience"
draft: false
---

## TypeScript Patterns I Use Every Day

After years of writing TypeScript professionally, certain patterns have become second nature. These aren't advanced type gymnastics—they're practical techniques that make everyday code safer and more maintainable.

### 1. Discriminated Unions for State

Instead of optional properties and boolean flags:

```typescript
// ❌ Avoid: Unclear state combinations
interface User {
  isLoading: boolean;
  isError: boolean;
  data?: UserData;
  error?: Error;
}

// ✅ Prefer: Discriminated union
type UserState =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: UserData }
  | { status: 'error'; error: Error };
```

The discriminated union makes impossible states unrepresentable. You can't have both `data` and `error` simultaneously.

### 2. Const Assertions for Literals

When you need literal types instead of widened primitives:

```typescript
// Without const assertion
const config = {
  endpoint: '/api/users',
  method: 'GET'
};
// Type: { endpoint: string; method: string }

// With const assertion
const config = {
  endpoint: '/api/users',
  method: 'GET'
} as const;
// Type: { readonly endpoint: '/api/users'; readonly method: 'GET' }
```

This is especially useful for configuration objects and route definitions.

### 3. Type Predicates for Filtering

Type-safe array filtering:

```typescript
function isNotNull<T>(value: T | null): value is T {
  return value !== null;
}

const items: (string | null)[] = ['a', null, 'b', null, 'c'];
const filtered = items.filter(isNotNull);
// Type: string[] (not (string | null)[])
```

### 4. Branded Types for IDs

Prevent mixing up different ID types:

```typescript
type UserId = string & { readonly brand: unique symbol };
type PostId = string & { readonly brand: unique symbol };

function createUserId(id: string): UserId {
  return id as UserId;
}

function getUser(id: UserId) { /* ... */ }
function getPost(id: PostId) { /* ... */ }

const userId = createUserId('user_123');
const postId = createPostId('post_456');

getUser(userId); // ✅ OK
getUser(postId); // ❌ Error: PostId not assignable to UserId
```

### 5. Exhaustive Switch Checking

Ensure all union cases are handled:

```typescript
type Status = 'pending' | 'approved' | 'rejected';

function assertNever(x: never): never {
  throw new Error(`Unexpected value: ${x}`);
}

function getStatusColor(status: Status): string {
  switch (status) {
    case 'pending': return 'yellow';
    case 'approved': return 'green';
    case 'rejected': return 'red';
    default: return assertNever(status);
  }
}
```

If someone adds a new status, TypeScript will error until the switch is updated.

### 6. Utility Types for Props

Building component prop types from existing types:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
  role: 'admin' | 'user';
}

// Props for a user form (omit readonly fields)
type UserFormProps = Omit<User, 'id' | 'createdAt'>;

// Props for user display (all optional for partial updates)
type UserPatch = Partial<User>;

// Props for user creation (require name and email)
type CreateUserProps = Pick<User, 'name' | 'email'> & Partial<Pick<User, 'role'>>;
```

### 7. Generic Constraints with Defaults

Flexible yet constrained generics:

```typescript
interface ApiResponse<T = unknown> {
  data: T;
  status: number;
  timestamp: Date;
}

// Works without specifying T
const response: ApiResponse = await fetch('/api');

// Or with specific type
const userResponse: ApiResponse<User> = await fetch('/api/user');
```

### Closing Thoughts

These patterns share a common theme: **making the type system work for you**. Good TypeScript isn't about adding types everywhere—it's about designing types that prevent bugs and communicate intent.

The best type definitions are the ones that make incorrect code fail to compile.
